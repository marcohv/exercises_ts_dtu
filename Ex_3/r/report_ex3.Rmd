---
header-includes: #allows you to add in your own Latex packages
- \usepackage{float} #use the 'float' package
- \floatplacement{figure}{H} #make every figure with caption = H
- \usepackage{color} #change text color

title: \Large Excercise 3 - Grey-box models (continued)
subtitle: Models for the heat dynamics of a building
author: "Marco Hernandez Velasco"
date: "August 2018"
output: 
  pdf_document:
    citation_package: natbib
bibliography: [references.bib, packages.bib]
---
```{r setup_bibliography, include=FALSE}
# automatically create a bib database for R packages
rm(list=ls()) # remove all variables in memory

knitr::write_bib(c(.packages(),  #make a bibliography for the packages
              #packages used that will be cited
                #basic packages used for Rmarkdown
                'knitr', 'rmarkdown',  
                #actual packages used  to solve
                'tidyverse', 'ctsmr', 'digest', 'lubridate', 'splines'),   
                'packages.bib') #file num to which the references will be saved to

#define other general chunk settings
knitr::opts_chunk$set(echo = TRUE, # show source code chunks in the output file
                      fig.height = 4, #figures height for all chunks
                      fig.align = "center") 
```
@* `r #includes all references in file, even those not mentioned in the text `

```{r initialize, message = FALSE, echo = FALSE}
library(readxl) # to import Excel files
library(tidyverse) # to use tidy data
library(ctsmr) #fro ctsmr modelling
library(digest)
library(lubridate) #managing date formats
library(splines) #model using splines

## Init by deleting all variables and functions
rm(list=ls())
## Set the working directory
setwd(".")

## Use the ctsmr package
library(ctsmr)
```

The exercise is focused on grey-box modelling of the heat dynamics of a (small) building using stochastic differential equations (SDEs). In addition to the first exercise on greybox modelling, we will in this exercise test different techniques to:  

1. Alter the noise level or system uncertainty to account for e.g. non-linear phenomena.

2. Build a semi-parametric model to take into account that the solar penetration (i.e. relation between measured solar radiation and radiation entering into the building) as function of the position of the sun.

3. Balance heat gains to the air temperature and the temperature of the thermal mass.  

The data consists of several measurement from a small test box with a single window. In this exercise the following signals are used:

  * Ti (yTi in data) the observed indoor temperatures. (C)  
  * Qi (Qi in data) the heat emitted by the electrical heaters in the test box (W)  
  * Te (Te in data) the ambient temperature (C)  
  * Gv (Gv in the data) the vertical south total solar radiation (W/m2)  
  * Gvn (Gvn in data) the vertical north total solar radiation (W/m2)  

# Question 1

```{r q1_plot, echo=FALSE, warning=FALSE, results='hide'}
## Source functions
sapply(dir("functions",full.names=TRUE), source)

## A list of parameters used in many functions
pg <- list()
## Rerun the models or read from cache?
pg$rerun <- FALSE
pg$cache_dir <- "cache_fits"
## Use first order interpolation when estimating?
pg$firstorder <- TRUE
## Number of threads used, keep at 1
pg$threads <- 1
## Latitude and longitude of the position
pg$latitude <- 37.097083
pg$longitude <- -2.364994

## Averaging period Ts is in minutes
X <- prepare_data(readSeries("X5", Ts=10, nlags=NA), samples_after_Qi_step = 5)

## Plot it
plotmulti(X, c("yTi","Te","Qi","G","stepQi"), xnm="timedate", ylab=c("Ti (c)","Te (C)","Qi (W)","Gv (W/m2)","stepQi"))

```
The lower time series plot is of stepQi, which goes from 0 to 1. Try to change the argument samples_after_Qi_step in the function preparing the data. How does it change stepQi?

\textcolor{blue}{Changing the stepQi makes the ON or OFF intervals longer or shorter and makes it able to correspond better to the actual heater's behavior. Like below with a step = 0.5}

```{r q1_step_qi_plot, echo=FALSE, warning=FALSE, results='hide'}
## changing samples_after_Qi_step
step_qi <- 0.5

X2 <- prepare_data(readSeries("X5", Ts=10, nlags=NA), samples_after_Qi_step = step_qi)

## Plot it
plotmulti(X2, c("yTi","Te","Qi","G","stepQi"), xnm="timedate", ylab=c("Ti (c)","Te (C)","Qi (W)","Gv (W/m2)","stepQi"))

```
## Comparing the two models

Now compare the two models implemented in **functions/sdeTiTw.R** and
**functions/sdeTiTw_sigmalevels.R**. What is the difference?

\textcolor{blue}{The second model includes with sigma levels include:}  

$(1+(stepQi*sigmalevel))$  

\textcolor{blue}{in the error term allowing to account for the noise of turning ON and OFF the heater.}

Now go to the script and fit the two models. Compare the results:
```{r q1_compare, echo=FALSE, warning=FALSE, results='hide'}
## Keep the fits in a list
Fits <- list()

## TiTw with constant system noise
Fits[["TiTw"]] <- sdeTiTw(X)
## Remember to step back and see the acf and cpgram
analyzeFit(Fits[["TiTw"]], type="s")

## TiTw with two leves of system noise
Fits[["TiTw_sigmalevels"]] <- sdeTiTw_sigmalevels(X)
analyzeFit(Fits[["TiTw_sigmalevels"]], type="s")
```

What is plotted in the upper two plots? (You maybe have to look into the
analyzeFit() function).

\textcolor{blue}{The upper plot is the residuals of the predicted variable \textbf{yTi}.} \textcolor{blue}{The lower plot is the standarized residuals (residuals / sd(yTi)), the y-axis changes as the errors are now divided by the standard deviation (sigma)}

What is indicated by the blue lines in the upper plot? Step back in the plots and compare the results, and look at the summary output.

\textcolor{blue}{The blue lines in the upper plot are the standard deviation of the predicted variable (\textbf{yTi}) by which the residuals are divided to be standarized in the second graph below.}

Step back in the plots and compare the results, and look at the summary output. Which of the two models will you prefer and why?
\textcolor{blue}{The one with sigma level because it allows the variance to change with time and captures better the variability of the process and that is shown in its residuals.When comparing their Log-Likelihood, also the model with sigma-levels has a larger likelihood.}  

So it becomes clear that we have some (possible non-linear) dynamics when the heating turns on and off, which our models doesn’t predict so well. But **instead of adding a more detailed description to the deterministic part of the model, we simply vary the system noise, or in other words, change the uncertainty level of our states under under different conditions**. This is a very useful thing, since there will be many phenomena in buildings, especially occupied buildings, which will lead different to levels of noise, e.g., solar radiation and occupants doing funny things.

```{r q1_nice, echo=FALSE, warning=FALSE, results='hide', eval = FALSE}
## Nice features of R and Rstudio

# Keeping the results in a list: ----

# Easy to extract the same value for all the fits
# E.g. compare the loglikelihoods
sapply(Fits, function(fit){ fit$loglik })

# Shortcuts for running the code in different ways in RStudio: ----
## See the menu around "Code->Run Region"

# Setting a break point in a function:----

## Open "functions/sdeTiTw.R" and click to the left of the "3" number indicating line 3
## A red circle will appear indicating a breakpoint
## Above the script, click on "Source on Save" to check it
## Press the disc sign to save
## Now go back and run the line with sdeTiTw(X)
## The execution stops and you can use the bottoms above the console to step through the code

# Caching results:----

## Look into the "functions/TiTw.R" in the first lines the cache_load() is called
## Go into "functions/cache_load.R", can you figure out what it does?
## Now run
sdeTiTw(X, rerun=TRUE)
## and try to change the value of return between TRUE and FALSE
## The results are cached in the folder "cache_fits", such that if a model was previously run on some data, instead of running again, it just opens the saved result from last time

# Keeping results in a list: ----

## You can easily do the same thing to all the fits, e.g. pick a value or do a plot to sum up results
## E.g. compare the loglikelihoods
sapply(Fits, function(fit){ fit$loglik })
```
\pagebreak

# Question 2
So far we have assumed that the solar gain is proportional to the radiation outside the test box. In reality, the heat gain from the sun depends highly on building geometry, surroundings, window properties, etc. In this part of the exercise, we will apply splines to estimate the solar heat gain as a function of solar position.  

First we make a hidden state for $Aw$ (also called the gA-value) to investigate if it changes over time and as the function of the sun position.
```{r q2_ini, echo=FALSE, warning=FALSE, results='hide'}
## Use the lubridate package
library(lubridate)

## Source functions
sapply(dir("functions",full.names=TRUE), source)

## A list of parameters used in many functions
pg <- list()
## Rerun the models or read from cache?
pg$rerun <- FALSE
pg$cache_dir <- "cache_fits"
## Use first order interpolation when estimating?
pg$firstorder <- TRUE
## Number of threads used, keep at 1
pg$threads <- 1
## Latitude and longitude of the position
pg$latitude <- 37.097083
pg$longitude <- -2.364994


## Averaging period Ts is in minutes
X <- prepare_data(readSeries("X5", Ts=10, nlags=NA), samples_after_Qi_step = 5)

## Plot it
plotmulti(X, c("yTi","Te","Qi","Gv","stepQi"), ylab=c("Ti (c)","Te (C)","Qi (W)","Gv (W/m2)","stepQi"))

## Plot the different solar radiation measuresments
plotmulti(X ,c("sunElevation$","Gh.1|Gv"))

## Set solar radiation to 0 when sun is below horizon
X$Gv[ X$sunElevation < 0 ] <- 0
X$Gh.1[ X$sunElevation < 0 ] <- 0

```

```{r q2_AW_change, echo=FALSE, warning=FALSE, results='hide'}
## Rename "Gh.1" to "Gh"
names(X)[names(X)=="Gh.1"] <- "Gh"

## Generate a new object of class ctsm
model <- ctsm$new()
## Add system equations and thereby also states
model$addSystem(dTi ~ ( 1/(Ci*Riw)*(Tw-Ti) + Aw/Ci*Gh + 1/Ci*Qi )*dt +
                  (1+(stepQi*sigmalevel))*exp(p11)*dw1)

model$addSystem(dTw ~ ( 1/(Cw*Riw)*(Ti-Tw) + 1/(Cw*Rwe)*(Te-Tw) )*dt +
                  (1+(stepQi*sigmalevel))*exp(p22)*dw2)

model$addSystem(Aw ~ exp(p33)*dw3)
## Set the names of the inputs
model$addInput(Te,Gh,Qi,stepQi)

## Set the observation equation: Ti is the state, yTi is the measured output
model$addObs(yTi ~ Ti)
## Set the variance of the measurement error
model$setVariance(yTi ~ exp(e11))

## Set the initial value (for the optimization) of the value of the state at the starting time point
model$setParameter(  Ti = c(init=35  ,lb=10    ,ub=45) )
model$setParameter(  Tw = c(init=34  ,lb=10    ,ub=45) )
model$setParameter(  Aw = c(init=0.2 ,lb=0.001 ,ub=3))

## Set the initial value of the parameters for the optimization
model$setParameter(  Ci = c(init=1E5 ,lb=1E4   ,ub=1E7) )
model$setParameter(  Cw = c(init=5E5 ,lb=1E4   ,ub=1E8) )
model$setParameter( Riw = c(init=0.1 ,lb=1E-5  ,ub=10) )
model$setParameter( Rwe = c(init=0.1 ,lb=1E-5  ,ub=10) )
model$setParameter( p11 = c(init=1   ,lb=-50   ,ub=10) )
model$setParameter( p22 = c(init=1   ,lb=-50   ,ub=10) )
model$setParameter( p33 = c(init=1   ,lb=-50   ,ub=10) )
model$setParameter( e11 = c(init=-1  ,lb=-50   ,ub=10) )
model$setParameter( sigmalevel= c(init=1  ,lb=0    ,ub=100) )

## Run the parameter optimization
fit <- model$estimate(data = X, firstorder=pg$firstorder, threads = pg$threads)

## Check model
summary(fit, extended = TRUE)

## Plot the Aw state

par(mfrow=c(2,1))
val <- predict(fit)[[1]]
plot(X$timedate, val$state$pred$Aw, 
     ylab = "Aw", 
     xlab = "Time")
plot(X$sunAzimuth, val$state$pred$Aw, 
     ylab = "Aw", 
     xlab = expression("Sun Azimuth ("*degree*")"))

```
It is clear that the state of $Aw$ is not constant, but changes. Furthermore, it seems like
there could be a relation to the sun azimuth.

Now, answer the questions below as you progress in modelling the solar radiation
with use of splines. The spline function we want to estimate is the **gA value** (e.g. the percentage of solar heat that enters through the window, multiplied with the window area) as a function of the sun azimuth.  
First, plot the sun elevation as a function of the sun azimuth, as well as a horizontal line through 0 (notice that the angles is in radians).  

```{r q2_gA, echo=FALSE, warning=FALSE, results='hide'}
plot(X$sunAzimuth, X$sunElevation)
abline(h = 0)
```
Find the azimuth angles (in radians) that corresponds to the sunrise and sunset, and assign them to azumith_bound <- c(... , ...) below. These two angles will in a moment be our boundary azimuth angles. Outside the boundaries the gA value is 0, as the sun is below the horizon and the radiation is zero. Thus, we are only interested in the gA values from sunrise to sunset.

```{r q2_angles, echo=FALSE, warning=FALSE}
## Inset the boundary angles (in radians) below.
a <- X %>% select(sunAzimuth, sunElevation) %>%  #select relevant colums
      mutate(sunAz = round(sunAzimuth,2), #round the azimuth
              #give the sign of the elevation
              #compare to previous/lagged sign, get absolute value
              #when there is a change it will be = 0
             sign_change = sign(sunElevation) + lag(sign(sunElevation))) %>%
      filter(sign_change == 0) %>%  #find the rows where it changes
      summarise(min_bound = min(sunAz), max_bound = max(sunAz)) #summarise to the min, max

#convert the above data frame to a vector of 2 values
azumith.bound<- as.vector(t(a)) #t() transposes the matrix to do it by columns

#is the same as:#azumith.bound <- c(1.05, 5.22)      

```
Define the base splines in the following lines of the script and stop after you have assigned the base splines to the data frame with the command X <- cbind(X,Xbs). Now play around with the four parameters in in the vector Aw, and plot the resulting spline function to get an understanding of how the base splines and the resulting spline function work.  


*(Pro tip: the package lubridate is very useful when working with dates and
time. Which often is the case for when dealing with time series!)*
```{r q2_gA_splines, echo=FALSE, warning=FALSE, results='hide'}
## Create base splines
Xbs <- as.data.frame(bs(X$sunAzimuth,
                        df=4,
                        Boundary.knots=c(azumith.bound[1],azumith.bound[2]),
                        intercept=TRUE))

## Name and assign to data frame
names(Xbs) <- pst("Gbs",names(Xbs))
X <- cbind(X,Xbs)

## Play around with these parameters
Aw <- c(0.7, 0.2, 1, 1.5)
# Plot spline function
with(subset(X, day(X$timedate) == 29),{
    plot((Aw[1] * ifelse(sunElevation > 0, Gbs1, NA) +
              Aw[2] * ifelse(sunElevation > 0, Gbs2, NA) +
              Aw[3] * ifelse(sunElevation > 0, Gbs3, NA) +
              Aw[4] * ifelse(sunElevation > 0, Gbs4, NA)),
         type = "l", ylab = "y")
})

```
What happens if Aw only consists of 1’s?

\textcolor{blue}{The result is just a straight line. These parameters determine how the spline function will look like} 
```{r q2_gA_splines2, echo=FALSE, warning=FALSE, results='hide'}

## Play around with these parameters
Aw_1 <- c(1, 1, 1, 1)
# Plot spline function
with(subset(X, day(X$timedate) == 29),{
    plot((Aw_1[1] * ifelse(sunElevation > 0, Gbs1, NA) +
              Aw_1[2] * ifelse(sunElevation > 0, Gbs2, NA) +
              Aw_1[3] * ifelse(sunElevation > 0, Gbs3, NA) +
              Aw_1[4] * ifelse(sunElevation > 0, Gbs4, NA)),
         type = "l", ylab = "y")
})

```
```{r q2_fit_model, echo=FALSE, warning=FALSE, results='hide'}

## Generate a new object of class ctsm
model <- ctsm$new()
## Add system equations and thereby also states
model$addSystem(dTi ~ ( 1/(Ci*Riw)*(Tw-Ti) + 1/Ci*Qi + Gv * (Aw1 * Gbs1 + Aw2 * Gbs2 + Aw3 * Gbs3 + Aw4 * Gbs4)/Ci)*dt + (1+(stepQi*sigmalevel))*exp(p11)*dw1)

model$addSystem(dTw ~ ( 1/(Cw*Riw)*(Ti-Tw) + 1/(Cw*Rwe)*(Te-Tw) )*dt + (1+(stepQi*sigmalevel))*exp(p22)*dw2)

## Set the names of the inputs
model$addInput(Te,Gv,Gbs1,Gbs2,Gbs3,Gbs4,Qi,stepQi)
##
## Set the observation equation: Ti is the state, yTi is the measured output
model$addObs(yTi ~ Ti)
## Set the variance of the measurement error
model$setVariance(yTi ~ exp(e11))
##
## Set the initial value (for the optimization) of the value of the state at the starting time point
model$setParameter(  Ti = c(init=35  ,lb=10    ,ub=45) )
model$setParameter(  Tw = c(init=34  ,lb=10    ,ub=45) )
## Set the initial value of the parameters for the optimization
model$setParameter(  Ci = c(init=1E5 ,lb=1E4   ,ub=1E7) )
model$setParameter(  Cw = c(init=5E5 ,lb=1E4   ,ub=1E8) )
model$setParameter( Riw = c(init=0.1 ,lb=1E-5  ,ub=10) )
model$setParameter( Rwe = c(init=0.1 ,lb=1E-5  ,ub=10) )
model$setParameter(  Aw1 = c(init=0.2 ,lb=0.000001 ,ub=3))
model$setParameter(  Aw2 = c(init=0.2 ,lb=0.001 ,ub=3))
model$setParameter(  Aw3 = c(init=0.2 ,lb=0.001 ,ub=3))
model$setParameter(  Aw4 = c(init=0.2 ,lb=0.001 ,ub=3))
model$setParameter( p11 = c(init=1   ,lb=-50   ,ub=10) )
model$setParameter( p22 = c(init=1   ,lb=-50   ,ub=10) )
model$setParameter( e11 = c(init=-1  ,lb=-50   ,ub=10) )
model$setParameter( sigmalevel= c(init=1  ,lb=0    ,ub=100) )
## Run the parameter optimization
fit <- model$estimate(data = X, firstorder=pg$firstorder, threads = pg$threads)

## Check model
summary(fit, extended = TRUE)

fit$data[[1]] <- X
fit$Rnames <- c("Riw","Rwe")
analyzeFit(fit)

```

```{r q2_gA_curve, echo=FALSE, warning=FALSE, results='hide'}

# Look at the gA curve:

# Save one-step predictions
val <- predict(fit)[[1]]

## Plot gA curve
dev.off()
xseq <- seq(1, 5, len = 100)
Xbs_seq <- bs(xseq, df=4, Boundary.knots=c(1,5), intercept=TRUE)
plot(xseq * 180 / (pi), Xbs_seq %*% fit$xm[c("Aw1","Aw2","Aw3","Aw4")],
     ylab = "gA splined", xlab = expression("Sun Azimuth ("*degree*")"), xlim = c(0, 360),
     type = "l", ylim = c(0, 0.12))
lines(xseq * 180 / (pi), Xbs_seq %*% (fit$xm[c("Aw1","Aw2","Aw3","Aw4")] +
                                          1.96 * fit$sd[c("Aw1","Aw2","Aw3","Aw4")]),lty="dashed")
lines(xseq * 180 / (pi), Xbs_seq %*% (fit$xm[c("Aw1","Aw2","Aw3","Aw4")] -
                                          1.96 * fit$sd[c("Aw1","Aw2","Aw3","Aw4")]),
      lty="dashed")

```